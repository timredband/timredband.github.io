---
title: 'Advent of code 2023 - day 2'
date: 2023-12-03
slug: advent-of-code-2023-day-2
tags:
    - go
    - advent of code 2023
---

Learning Go through problem solving

---

Read day one [here](/blog/advent-of-code-2023-day-1).

## Part One

### Understanding the problem

Read the problem [here](https://adventofcode.com/2023/day/2). Looks like the general idea is for each hand in each game to make sure that the amount of any color of cube does not exceed the max for each color. The hard part of this problem is really just parsing the input.

### Solution

I'm going to read in the input using my file utility I wrote in [day one](/blog/advent-of-code-2023-day-1). For each line I'll split on the ":" and take the second part so I'm only dealing with each hand.

```
Game 1: 3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green
```

to

```
 3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green
```

Then I'll split that line by ";" to get the text for each hand to end up with an array like this:

```
["3 blue, 4 red", "1 red, 2 green, 6 blue", "2 green"]
```

Then I'll loop through each hand and split on ", " to get down to a number and a color. So for the first hand we're left with

```
["3 blue", "4 red"]
```

Finally split on " " to get a single number and single color.

```
[3, blue]
[4, red]
```

From there we'll make sure the red amount is less than 12, the green amount (if there was one) if less than 13, and the red amount is less than 15.

If each hand in a game is valid then we'll add the game number to the result. It'll be our loop variable plus one since we start at zero and the games start at one.

```go
func main() {
    var inputs []string = file.ReadFile("inputs/2.txt")

    result := 0

lines:
    for i := 0; i < len(inputs); i += 1 {
        game := strings.Split(inputs[i], ":")[1]

        handfuls := strings.Split(game, ";")

        for _, hand := range handfuls {
            hand = strings.TrimSpace(hand)
            groups := strings.Split(hand, ", ")

            for _, group := range groups {
                colorCount := strings.Split(group, " ")

                count, err := strconv.Atoi(colorCount[0])
                if err != nil {
                    panic(err)
                }

                color := colorCount[1]

                switch color {
                case "red":
                    if count > 12 {
                        continue lines
                    }
                case "green":
                    if count > 13 {
                        continue lines
                    }
                case "blue":
                    if count > 14 {
                        continue lines
                    }
                default:
                    panic("default")
                }
            }
        }

        result += (i + 1)
    }

    fmt.Println(result)
}
```

That's all for part one. I learned how to use labels to continue loops if a condition is not met. I'm not sure this is good or bad as it's similar to javascript labels and those don't get much use.

## Part Two

### Understanding the problem

Part two is very similar to part one except it's asking for the minimum number of cubes to make each game valid. To find that we just need to find the max color used in each hand for each game. Instead of breaking our loop if the colors are greater than the color counts, we keep track of the max of each color.

### Solution

```go
func main() {
    var inputs []string = file.ReadFile("inputs/2.txt")

    result := 0

    for i := 0; i < len(inputs); i += 1 {
        game := strings.Split(inputs[i], ":")[1]

        handfuls := strings.Split(game, ";")

        maxRed := -1
        maxGreen := -1
        maxBlue := -1

        for _, hand := range handfuls {
            hand = strings.TrimSpace(hand)
            groups := strings.Split(hand, ", ")

            for _, group := range groups {
                colorCount := strings.Split(group, " ")

                count, err := strconv.Atoi(colorCount[0])
                if err != nil {
                    panic(err)
                }

                color := colorCount[1]

                switch color {
                case "red":
                    maxRed = max(maxRed, count)
                case "green":
                    maxGreen = max(maxGreen, count)
                case "blue":
                    maxBlue = max(maxBlue, count)
                default:
                    panic("default")
                }
            }
        }

        result += (maxRed * maxGreen * maxBlue)
    }

    fmt.Println(result)
}
```

And that concludes day two. Stay tuned for day three!
